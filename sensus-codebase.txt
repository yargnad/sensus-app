// --- FILE: client/src/App.js ---

import React, { useState, useEffect } from 'react';
import './App.css';
import SubmissionForm from './components/SubmissionForm';
import MatchedContent from './components/MatchedContent';
import CooldownTimer from './components/CooldownTimer';
import ErrorBoundary from './components/ErrorBoundary';

const API_URL = 'http://localhost:5000';

function App() {
    const [showForm, setShowForm] = useState(false);
    const [matchedContent, setMatchedContent] = useState(null);
    const [waiting, setWaiting] = useState(false);
    const [submissionId, setSubmissionId] = useState(null);
    const [cooldownTime, setCooldownTime] = useState(null);

    useEffect(() => {
        const lastSubmissionTime = localStorage.getItem('sensus_last_submission');
        const lastSubmissionId = localStorage.getItem('sensus_submission_id');

        if (lastSubmissionTime) {
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const timePassed = Date.now() - new Date(lastSubmissionTime).getTime();

            if (timePassed < twentyFourHours) {
                setCooldownTime(twentyFourHours - timePassed);
                if (lastSubmissionId) {
                    fetch(`${API_URL}/api/check/${lastSubmissionId}`)
                        .then(res => res.json())
                        .then(data => {
                            if (data.status === 'matched') {
                                setMatchedContent(data.matchData);
                            }
                        })
                        .catch(err => console.error("Error fetching last match:", err));
                }
            } else {
                localStorage.removeItem('sensus_last_submission');
                localStorage.removeItem('sensus_submission_id');
                localStorage.removeItem('sensus_session_token');
            }
        }
    }, []);

    useEffect(() => {
        if (!waiting || !submissionId) return;

        const intervalId = setInterval(() => {
            fetch(`${API_URL}/api/check/${submissionId}`)
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'matched') {
                        setMatchedContent(data.matchData);
                        setWaiting(false);
                        localStorage.setItem('sensus_submission_id', submissionId);
                        setSubmissionId(null);
                    }
                })
                .catch(err => {
                    console.error("Error checking status:", err);
                    setWaiting(false);
                });
        }, 5000);

        return () => clearInterval(intervalId);
    }, [waiting, submissionId]);

    const handleShareClick = () => setShowForm(true);

    const handleSubmission = async (formData) => {
        setShowForm(false);
        setWaiting(true);

        try {
            const res = await fetch(`${API_URL}/api/submit`, { method: 'POST', body: formData });
            const data = await res.json();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const submissionTime = data.lastSubmissionTime || data.submissionTime;
            const timePassed = Date.now() - new Date(submissionTime).getTime();
            setCooldownTime(twentyFourHours - timePassed);

            if (res.status === 429) {
                setWaiting(false);
                if (data.lastSubmissionId) {
                    fetch(`${API_URL}/api/check/${data.lastSubmissionId}`)
                        .then(res => res.json())
                        .then(matchData => {
                            if (matchData.status === 'matched') setMatchedContent(matchData.matchData);
                        });
                }
                return;
            }

            localStorage.setItem('sensus_session_token', data.sessionToken);
            localStorage.setItem('sensus_last_submission', data.submissionTime);
            localStorage.setItem('sensus_submission_id', data.submissionId);

            if (data.status === 'matched') {
                setMatchedContent(data.matchData);
                setWaiting(false);
            } else if (data.status === 'waiting') {
                setSubmissionId(data.submissionId);
            }
        } catch (error) {
            console.error("Error during submission:", error);
            setWaiting(false);
        }
    };

    let mainContent;
    if (matchedContent) {
        mainContent = <MatchedContent content={matchedContent} apiUrl={API_URL} />;
    } else if (waiting) {
        mainContent = <div className="waiting-message">Waiting for a match...</div>;
    } else if (cooldownTime > 0) {
        mainContent = <div className="waiting-message">Retrieving your last match...</div>;
    } else {
        mainContent = showForm
            ? <SubmissionForm onSubmit={handleSubmission} />
            : <button className="share-button" onClick={handleShareClick}>Share a Feeling</button>;
    }

    return (
        <ErrorBoundary>
            <div className="App">
                {cooldownTime > 0 && (
                    <div className="cooldown-timer-wrapper">
                        <CooldownTimer initialTime={cooldownTime} />
                    </div>
                )}
                <div className="content-frame">
                    {mainContent}
                </div>
            </div>
        </ErrorBoundary>
    );
}

export default App;

// --- FILE: client/src/components/SubmissionForm.js ---

import React, { useState } from 'react';

const SubmissionForm = ({ onSubmit }) => {
    const [text, setText] = useState('');
    const [file, setFile] = useState(null);

    const handleSubmit = (e) => {
        e.preventDefault();
        const formData = new FormData();
        if (text) {
            formData.append('text', text);
        } else if (file) {
            formData.append('file', file);
        }
        onSubmit(formData);
    };

    return (
        <form onSubmit={handleSubmit}>
            <div>
                <textarea
                    placeholder="Share a poem or a thought..."
                    value={text}
                    onChange={(e) => {
                        setText(e.target.value);
                        setFile(null);
                    }}
                    rows="4"
                    cols="50"
                ></textarea>
            </div>
            <div>
                <p>OR</p>
            </div>
            <div>
                <input
                    type="file"
                    accept="image/*,audio/*"
                    onChange={(e) => {
                        setFile(e.target.files[0]);
                        setText('');
                    }}
                />
            </div>
            <button type="submit">Submit</button>
        </form>
    );
};

export default SubmissionForm;

// --- FILE: client/src/components/MatchedContent.js ---

import React from 'react';

const MatchedContent = ({ content, apiUrl }) => {
    const getFileUrl = (filePath) => {
        // The server is configured to serve static files from the 'uploads' directory
        return `${apiUrl}/${filePath}`;
    };

    return (
        <div className="content-frame">
            <div className="matched-content">
                {content.contentType === 'text' && <p>{content.content}</p>}
                {content.contentType === 'image' && (
                    <img src={getFileUrl(content.content)} alt="A feeling from another" />
                )}
                {content.contentType === 'audio' && (
                    <audio controls src={getFileUrl(content.content)} />
                )}
            </div>
        </div>
    );
};

export default MatchedContent;

// --- FILE: client/src/components/CooldownTimer.js ---

import React, { useState, useEffect } from 'react';

const CooldownTimer = ({ initialTime }) => {
    const [timeLeft, setTimeLeft] = useState(initialTime);

    useEffect(() => {
        if (timeLeft <= 0) return;

        const intervalId = setInterval(() => {
            setTimeLeft(prevTime => prevTime - 1000);
        }, 1000);

        return () => clearInterval(intervalId);
    }, [timeLeft]);

    const formatTime = (ms) => {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    };

    if (timeLeft <= 0) {
        return null;
    }

    return (
        <div className="cooldown-timer-content">
            <h2>You have shared a feeling recently.</h2>
            <p>You can share another in:</p>
            <div className="cooldown-timer-display">{formatTime(timeLeft)}</div>
        </div>
    );
};

export default CooldownTimer;

// --- FILE: client/src/components/ErrorBoundary.js ---

import React from 'react';

class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false, error: null, errorInfo: null };
    }

    static getDerivedStateFromError(error) {
        // Update state so the next render will show the fallback UI.
        return { hasError: true };
    }

    componentDidCatch(error, errorInfo) {
        // You can also log the error to an error reporting service
        console.error("Uncaught error:", error, errorInfo);
        this.setState({ error: error, errorInfo: errorInfo });
    }

    render() {
        if (this.state.hasError) {
            // You can render any custom fallback UI
            return (
                <div className="App">
                    <h2>Something went wrong.</h2>
                    <details style={{ whiteSpace: 'pre-wrap', textAlign: 'left' }}>
                        {this.state.error && this.state.error.toString()}
                        <br />
                        {this.state.errorInfo && this.state.errorInfo.componentStack}
                    </details>
                </div>
            );
        }

        return this.props.children;
    }
}

export default ErrorBoundary;


// --- FILE: server/server.js ---

require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const apiRoutes = require('./routes/api');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());
app.use('/uploads', express.static('uploads'));

// DB Config
const db = 'mongodb://localhost:27017/sensus'; // Replace with your MongoDB connection string

// Connect to MongoDB
mongoose
    .connect(db)
    .then(() => console.log('MongoDB Connected...'))
    .catch(err => console.log(err));

// Use Routes
app.use('/api', apiRoutes);

// Serve static assets if in production
if (process.env.NODE_ENV === 'production') {
    // Set static folder
    app.use(express.static(path.join(__dirname, '../client/build')));

    app.get('*', (req, res) => {
        res.sendFile(path.resolve(__dirname, '../client/build', 'index.html'));
    });
}

app.listen(PORT, '0.0.0.0', () => console.log(`Server started on port ${PORT}`));

// --- FILE: server/routes/api.js ---

const express = require('express');
const router = express.Router();
const multer = require('multer');
const axios = require('axios');
const fs = require('fs');
const crypto = require('crypto');
const Submission = require('../models/Submission');

// Multer config for file uploads
// ... existing code ...
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'uploads/');
    },
    filename: function (req, file, cb) {
        cb(null, Date.now() + '-' + file.originalname);
    }
});
const upload = multer({ storage: storage });

const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`;
const GEMINI_VISION_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`;


async function getEmotionalVector(submission) {
// ... existing code ...
    try {
        let requestBody;
        let apiUrl;

        if (submission.contentType === 'text') {
            apiUrl = GEMINI_API_URL;
            requestBody = {
                contents: [{
                    parts: [{
                        text: `Analyze the following text and provide a concise emotional summary as a comma-separated list of 5-10 keywords (e.g., hopeful, melancholic, serene, chaotic, joyful): "${submission.content}"`
                    }]
                }]
            };
        } else if (submission.contentType === 'image') {
            apiUrl = GEMINI_VISION_API_URL;
            const imageBytes = fs.readFileSync(submission.content).toString('base64');
            requestBody = {
                contents: [{
                    parts: [
                        { text: "Analyze the following image and provide a concise emotional summary as a comma-separated list of 5-10 keywords (e.g., hopeful, melancholic, serene, chaotic, joyful)." },
                        { inline_data: { mime_type: "image/jpeg", data: imageBytes } }
                    ]
                }]
            };
        } else {
            // Placeholder for audio - Gemini API for audio is more complex
            // For now, we'll return a generic vector
            console.log('Audio analysis not yet implemented, returning generic vector.');
            return ['neutral'];
        }

        const response = await axios.post(apiUrl, requestBody);
        const summary = response.data.candidates[0].content.parts[0].text;
        return summary.split(',').map(kw => kw.trim().toLowerCase());

    } catch (error) {
        console.error('Error calling Gemini API:', error.response ? error.response.data : error.message);
        // Return a generic vector on error to avoid breaking the matching logic
        return ['error'];
    }
}


async function findAndPairMatch(submission) {
    // Atomically find a suitable unmatched submission and update it to prevent race conditions.
    // This operation finds a document and updates it in a single atomic step.
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

    const match = await Submission.findOneAndUpdate(
        {
            // Find criteria
            status: 'unmatched',
            _id: { $ne: submission._id },
            createdAt: { $gte: fiveMinutesAgo },
            emotionalVector: { $in: submission.emotionalVector }
        },
        {
            // Update to apply atomically
            $set: {
                status: 'matched',
                matchedWith: submission._id
            }
        },
        {
            // Options
            new: true, // Return the document *after* the update has been applied
            sort: { createdAt: 'desc' } // Find the most recent match
        }
    );

    return match;
}


// @route   POST api/submit
// @desc    Create a new submission and find a match
// @access  Public
router.post('/submit', upload.single('file'), async (req, res) => {
    try {
        const { sessionToken, text } = req.body;

        // --- 24-Hour Submission Limit Check ---
        if (sessionToken) {
            const lastSubmission = await Submission.findOne({ sessionToken }).sort({ createdAt: -1 });
            if (lastSubmission) {
                const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
                if (lastSubmission.createdAt > twentyFourHoursAgo) {
                    return res.status(429).json({ 
                        msg: 'You can only submit once every 24 hours.',
                        lastSubmissionTime: lastSubmission.createdAt,
                        lastSubmissionId: lastSubmission._id // Send back the ID
                    });
                }
            }
        }
        
        const newSessionToken = sessionToken || crypto.randomBytes(16).toString('hex');
        
        let newSubmission;

        if (text) {
            newSubmission = new Submission({
                contentType: 'text',
                content: text,
                sessionToken: newSessionToken
            });
        } else if (req.file) {
            newSubmission = new Submission({
                contentType: req.file.mimetype.startsWith('image') ? 'image' : 'audio',
                content: req.file.path,
                sessionToken: newSessionToken
            });
        } else {
            return res.status(400).json({ msg: 'No content submitted.' });
        }

        // 1. Get emotional vector from Gemini
        const vector = await getEmotionalVector(newSubmission);
        newSubmission.emotionalVector = vector;
        // Don't save yet, we need to see if we find a match first.

        // 2. Try to find and pair a match atomically
        const match = await findAndPairMatch(newSubmission);

        if (match) {
            // 3. If match found, update our new submission to complete the pair
            newSubmission.status = 'matched';
            newSubmission.matchedWith = match._id;
            await newSubmission.save();

            // The 'match' document is already updated in the DB by findOneAndUpdate.
            // Now we return the matched content to the user who just submitted.
            res.json({
                status: 'matched',
                matchData: {
                    contentType: match.contentType,
                    content: match.content
                },
                sessionToken: newSessionToken,
                submissionTime: newSubmission.createdAt,
                submissionId: newSubmission._id
            });
        } else {
            // 4. If no match, save the new submission as 'unmatched' and wait.
            await newSubmission.save();
            res.json({
                status: 'waiting',
                submissionId: newSubmission._id,
                sessionToken: newSessionToken,
                submissionTime: newSubmission.createdAt
            });
        }

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   GET api/check/:id
// @desc    Check the status of a submission
// @access  Public
// ... existing code ...
router.get('/check/:id', async (req, res) => {
    try {
        const submission = await Submission.findById(req.params.id);

        if (!submission) {
            return res.status(404).json({ msg: 'Submission not found' });
        }

        if (submission.status === 'matched') {
            const match = await Submission.findById(submission.matchedWith);
            res.json({
                status: 'matched',
                matchData: {
                    contentType: match.contentType,
                    content: match.content
                }
            });
        } else {
            res.json({ status: 'waiting' });
        }
    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

module.exports = router;

// --- FILE: server/models/Submission.js ---

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

// Create Schema
const SubmissionSchema = new Schema({
    contentType: {
        type: String,
        required: true // 'text', 'image', 'audio'
    },
    content: {
        type: String, // For text content or file path
        required: true
    },
    emotionalVector: {
        type: [String],
        default: []
    },
    status: {
        type: String,
        default: 'unmatched' // 'unmatched', 'matching', 'matched'
    },
    matchedWith: {
        type: Schema.Types.ObjectId,
        ref: 'submissions',
        default: null
    },
    sessionToken: {
        type: String,
        required: true,
        index: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    expireAt: {
        type: Date,
        default: Date.now,
        index: { expires: '60d' }
    }
});

module.exports = Submission = mongoose.model('submissions', SubmissionSchema);

// --- SKIPPED: File not found at package.json ---

// --- FILE: client/package.json ---

{
  "name": "sensus-client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "workbox-background-sync": "^7.3.0",
    "workbox-broadcast-update": "^7.3.0",
    "workbox-cacheable-response": "^7.3.0",
    "workbox-core": "^7.3.0",
    "workbox-expiration": "^7.3.0",
    "workbox-google-analytics": "^7.3.0",
    "workbox-navigation-preload": "^7.3.0",
    "workbox-precaching": "^7.3.0",
    "workbox-range-requests": "^7.3.0",
    "workbox-routing": "^7.3.0",
    "workbox-strategies": "^7.3.0",
    "workbox-streams": "^7.3.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


// --- FILE: server/package.json ---

{
    "name": "sensus-server",
    "version": "1.0.0",
    "description": "Server for Sensus app",
    "main": "server.js",
    "scripts": {
        "start": "node server.js"
    },
    "dependencies": {
        "axios": "^1.12.2",
        "cors": "^2.8.5",
        "dotenv": "^17.2.2",
        "express": "^4.18.2",
        "mongoose": "^7.0.0",
        "multer": "^1.4.5-lts.1"
    }
}


// --- FILE: README.md ---

# Sensus
### An Antidote to the Performance Prison.

---

## The Philosophy
We live in a world of digital connection that often leaves us feeling more alone. Mainstream social platforms, originally designed to connect us, have evolved into engines of engagement, trapping users in a **Performance Prison**. They are systems that reward performative outrage, gamify social validation, and monetize our attention, often at the expense of our authenticity and well-being.

Sensus is a rebellion against this. It is a social experiment and a proof of concept for a different kind of digital space—one designed not for metrics, but for meaning; not for virality, but for vulnerability. It is a tool built to foster a single, serendipitous moment of genuine human connection, free from the noise of the attention economy.

---

## How It Works
The Sensus experience is built on a foundation of deliberate minimalism and radical privacy.

*   **One Daily Act of Creation**: Once every 24 hours, you can share a single piece of your inner world—a poem, a photograph, a drawing, or a piece of music that captures a genuine thought or feeling.

*   **Complete Anonymity**: There are no profiles, no usernames, no follower counts, and no public metrics of any kind. Your submission is an anonymous gift to the void.

*   **A Single Serendipitous Match**: In return, you will receive a single, anonymous submission from another user. The match is made by an AI engine (Gemini) that analyzes the emotional and thematic core of the content, creating a surprising and thoughtful pairing.

*   **Ephemeral by Design**: This one-to-one exchange is the entire experience. After 24 hours, the match disappears. There is no history to collect, no gallery to curate. There is only the present moment of connection.

---

## The Technology
Sensus is a practical application of our "Team Hybrid" philosophy, where human creativity is the fuel and ethical AI is the engine.

*   **Front-End**: `React`
*   **Back-End**: `Node.js` with `Express`
*   **Database**: `MongoDB` with a Time-to-Live (TTL) index to ensure all submissions are automatically and permanently deleted after a set period, respecting the ephemeral nature of the project.
*   **The Heart**: The multimodal `Gemini API` serves as the "serendipity engine," performing the emotional analysis required to make thoughtful matches.

---

## Our Mission
Sensus is more than an app; it is a tangible argument. It is an open-source project dedicated to exploring and building humane technology. Our mission is to:

*   **Provide an Antidote**: Offer a quiet, contemplative space as a practical alternative to the toxic dynamics of the Performance Prison.
*   **Demonstrate Ethical AI**: Serve as a case study for a compassionate, "affinitive" application of AI that fosters empathy and self-reflection.
*   **Build a Community**: Create a collaborative, open-source community dedicated to the principles of the "Agile Rebellion"—making the world better, one small, thoughtful piece of code at a time.

---

## How to Contribute
This is a fledgling project born from a deep philosophical inquiry. We welcome collaborators of all kinds—developers, designers, writers, artists, and thinkers—who are passionate about our mission. If you believe in building a more authentic digital world, please feel free to open an issue, submit a pull request, or join the discussion.

---

## License
This project is licensed under the MIT License.


